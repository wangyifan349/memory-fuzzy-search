# 协同过滤推荐算法详解

本文介绍三种主流的协同过滤（Collaborative Filtering, CF）方法，并附带精简可运行的 Python 代码示例，代码中包含详细注释。

目录  
1. 用户–用户协同过滤（User-based CF）  
2. 物品–物品协同过滤（Item-based CF）  
3. 矩阵分解（Matrix Factorization via SVD）  
4. 方法对比与工程落地建议  

---

## 1. 用户–用户协同过滤（User-based CF）

思路  
1. 将用户–物品评分转为「用户–物品」矩阵；  
2. 计算目标用户与其他用户之间的相似度（如余弦相似度）；  
3. 找到 K 个最相似的用户（邻居），基于这些邻居的评分对目标用户未评分的物品做加权预测；  
4. 推荐预测评分最高的 N 个物品。

关键公式  
预测评分 $\hat r_{u,i} = \bar r_u + \frac{\sum_{v\in\mathcal{N}_u} w_{u,v}\,(r_{v,i}-\bar r_v)}{\sum_{v\in\mathcal{N}_u} |w_{u,v}|}$  
其中  
- $\mathcal{N}_u$：与用户 $u$ 最相似的 K 个邻居；  
- $w_{u,v}$：用户 $u$ 与 $v$ 的相似度；  
- $\bar r_u$：用户 $u$ 的平均评分。

代码示例（Python）  
```python
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

def user_cf(df, target_user, k=3, n=5):
    """
    基于用户的协同过滤推荐
    :param df: pandas.DataFrame, 包含 ['user','item','rating']
    :param target_user: 目标用户 ID
    :param k: 取最相似用户的数量
    :param n: 推荐物品数量
    :return: pandas.Series, 索引为物品 ID，值为预测评分
    """
    # 1. 构建用户-物品评分矩阵
    M = df.pivot(index='user', columns='item', values='rating').fillna(0)
    # 2. 计算用户-用户余弦相似度矩阵
    sim_matrix = pd.DataFrame(
        cosine_similarity(M),
        index=M.index,
        columns=M.index
    )
    # 3. 找到目标用户的 K 个最近邻（排除自己）
    neighbors = sim_matrix[target_user].drop(target_user).nlargest(k).index
    # 4. 预测目标用户对未评分物品的评分
    mu_u = M.loc[target_user].replace(0, np.NaN).mean()  # 用户 u 的平均评分
    scores = {}
    for item in M.columns:
        if M.at[target_user, item] > 0:
            continue  # 已评分则跳过
        num = den = 0.0
        for v in neighbors:
            r_vi = M.at[v, item]
            if r_vi == 0:
                continue  # 邻居未评分跳过
            mu_v = M.loc[v].replace(0, np.NaN).mean()
            w_uv = sim_matrix.at[target_user, v]
            num += w_uv * (r_vi - mu_v)
            den += abs(w_uv)
        if den > 0:
            scores[item] = mu_u + num / den
    # 返回 Top-N 物品
    return pd.Series(scores).nlargest(n)

# 示例
if __name__ == "__main__":
    data = [
        ('A','i1',5),('A','i2',3),
        ('B','i1',4),('B','i3',2),
        ('C','i2',5),('C','i3',3)
    ]
    df = pd.DataFrame(data, columns=['user','item','rating'])
    recs = user_cf(df, target_user='A', k=2, n=3)
    print("User-based CF 推荐：\n", recs)
```

---

## 2. 物品–物品协同过滤（Item-based CF）

思路  
1. 构建用户–物品评分矩阵；  
2. 计算物品–物品相似度矩阵（余弦相似度或皮尔逊相关等）；  
3. 对目标用户未评分的每个物品，基于该物品与用户已评分物品的相似度及用户评分做加权平均预测；  
4. 选取预测最高的 N 个物品推荐。

关键公式  
$\hat r_{u,i} = \frac{\sum_{j\in R_u} s_{i,j}\,r_{u,j}}{\sum_{j\in R_u} |s_{i,j}|}$  
其中  
- $R_u$：用户 $u$ 已评分过的物品集合；  
- $s_{i,j}$：物品 $i$ 与物品 $j$ 的相似度；  
- $r_{u,j}$：用户 $u$ 对物品 $j$ 的真实评分。

代码示例（Python）  
```python
import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity

def item_cf(df, target_user, n=5):
    """
    基于物品的协同过滤推荐
    :param df: pandas.DataFrame, 包含 ['user','item','rating']
    :param target_user: 目标用户 ID
    :param n: 推荐物品数量
    :return: pandas.Series, 索引为物品 ID，值为预测评分
    """
    # 1. 构建用户-物品评分矩阵
    M = df.pivot(index='user', columns='item', values='rating').fillna(0)
    # 2. 计算物品-物品余弦相似度
    item_sim = pd.DataFrame(
        cosine_similarity(M.T),
        index=M.columns,
        columns=M.columns
    )
    # 3. 目标用户对所有物品的评分向量
    user_ratings = M.loc[target_user]
    scores = {}
    for item in M.columns:
        if user_ratings[item] > 0:
            continue  # 已评分跳过
        # 分子：sum_{j∈已评分} (s_{i,j} * r_{u,j})
        num = (item_sim[item] * user_ratings).sum()
        # 分母：sum_{j∈已评分} |s_{i,j}|
        den = item_sim[item][user_ratings > 0].abs().sum()
        if den > 0:
            scores[item] = num / den
    return pd.Series(scores).nlargest(n)

# 示例
if __name__ == "__main__":
    data = [
        ('u1','p1',5),('u1','p2',3),
        ('u2','p1',4),('u2','p3',2),
        ('u3','p2',5),('u3','p3',3)
    ]
    df = pd.DataFrame(data, columns=['user','item','rating'])
    recs = item_cf(df, target_user='u1', n=3)
    print("Item-based CF 推荐：\n", recs)
```

---

## 3. 矩阵分解（Matrix Factorization via SVD）

思路  
1. 将评分矩阵 $R\in\mathbb{R}^{m\times n}$ 去中心化（减去用户或物品平均值）；  
2. 对中心化后的矩阵进行低秩分解（SVD、ALS、SGD 等）；  
3. 重构评分并加回均值，得到预测评分矩阵 $\hat R$；  
4. 根据 $\hat R$ 为用户推荐未评分且预测值最高的物品。

关键步骤  
- R = U Σ V^T，保留前 k 个奇异值；  
- 预测矩阵 $\hat R = U_k Σ_k V_k^T + \mu$。

代码示例（Python + SciPy）  
```python
import pandas as pd
import numpy as np
from scipy.sparse.linalg import svds

def mf_svd(df, target_user, k=2, n=5):
    """
    基于 SVD 的矩阵分解推荐
    :param df: pandas.DataFrame, 包含 ['user','item','rating']
    :param target_user: 目标用户 ID
    :param k: 隐因子维度
    :param n: 推荐物品数量
    :return: pandas.Series, 索引为物品 ID，值为预测评分
    """
    # 1. 构建原始评分矩阵
    M = df.pivot(index='user', columns='item', values='rating').fillna(0)
    R = M.values
    # 2. 去中心化（按用户平均）
    user_means = np.mean(R, axis=1).reshape(-1, 1)
    R_centered = R - user_means
    # 3. SVD 分解，仅保留 k 个奇异值
    U, sigma, Vt = svds(R_centered, k=k)
    Sigma = np.diag(sigma)
    # 4. 重构并加回均值
    R_hat = np.dot(np.dot(U, Sigma), Vt) + user_means
    pred_df = pd.DataFrame(R_hat, index=M.index, columns=M.columns)
    # 5. 筛选未评分项并取 Top-N
    watched = M.loc[target_user] > 0
    recommendations = pred_df.loc[target_user][~watched].nlargest(n)
    return recommendations

# 示例
if __name__ == "__main__":
    data = [
        ('U','x1',5),('U','x2',3),
        ('V','x1',4),('V','x3',2),
        ('W','x2',5),('W','x3',3)
    ]
    df = pd.DataFrame(data, columns=['user','item','rating'])
    recs = mf_svd(df, target_user='U', k=2, n=3)
    print("Matrix Factorization (SVD) 推荐：\n", recs)
```

---

## 4. 方法对比与工程落地建议

- User-based CF  
  - 优点：易理解、实现简单；适合小规模、多交互场景（如社交网络）。  
  - 缺点：计算用户相似度开销大，稀疏矩阵下效果欠佳；不易扩展。

- Item-based CF  
  - 优点：物品相似度可离线计算，实时推荐速度快；相对稳定。  
  - 缺点：新物品冷启动；相似度矩阵维护开销随物品量增大。

- 矩阵分解（MF）  
  - 优点：可学习潜在特征，缓解稀疏性问题；推荐精度高。  
  - 缺点：训练成本高；需要调参（隐因子维度、正则等）；冷启动需结合内容/社交信息。

工程实践中常用策略  
- Top-K 截断：对相似度矩阵每行只保留 Top-K，以节省存储与计算；  
- 时间衰减：对评分或相似度根据时间打权，捕捉用户兴趣变化；  
- 内容混合：结合基于内容（Content-based）或知识图谱方法，降低冷启动影响；  
- 分布式计算：Spark MLlib、Flink、MapReduce 等分布式框架；  
- 在线／离线结合：相似度/模型离线训练；特征抽取与召回实时化。  

